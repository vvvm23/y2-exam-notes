\documentclass[../models.tex]{subfiles}

\begin{document}

\subsection{CTL Syntax}

An LTL formula's natural interpretation is over paths. We interpret such a formula over a state by insisting that is satisfies all paths from the state. Thus, in LTL we cannot express a property of the form "it is always possible to enter another state that satisfies" since it requires an existential quantifier.

Therefore, it is nice to have a temporal logic that differentiates between path and state properties. CTL is such a logic whose formulae interpret over branching time (over all possible paths rather than linear time)

\textit{CTL and LTL are incomparable but there is another logic CTL* that subsumes both.}
\\

A state-fomrula in CTL is defined by the following grammar:

\begin{center}
    $\Phi = \text{true} | a | \Phi_1 \wedge \Phi_2 | \neg \Phi | A \phi | E \phi$
\end{center}

where $a$ is an atomic proposition and $\Phi_1, \Phi_2$ are state-formulae and $\phi$ is a path-formula defined by:

\begin{center}
    $\phi = X \Phi | G \Phi | F \Phi | \Phi_1 \bigcup \Phi_2 | \Phi_1 W \Phi_2$
\end{center}

Here $A$ (for All) and $E$ (there exists) are quantifiers over paths and $X$ (neXt), $G$ (Globally, always), $F$ (Finally, eventually), $U$ (Until), $W$ (Weak until or unless) are path-specific quantifiers.

\textit{ $U$ is like until, except $\Phi_2$ may never happen }

Informally, the quantifiers should come in pairs, a quantifier over paths followed by a path specific one.
\\

\subsection{CTL Semantics}

Given a set of atomic propositions $AP$ and a transition system $TS = (S, \rightarrow , I, AP, L)$ the satisfaction relation is defined recursively by:

\begin{center}
    \begin{itemize}
        \item $s \models \text{true}$ 
        \item $s \models a$ iff $a \in L(s)$
        \item $s \models \Phi_1 \wedge \Phi_2$ iff $s \models \Phi_1$ and $s \models \Phi_2$
        \item $s \models \neg \Phi$ iff $s \nvDash \Phi$
        \item $s \models A \phi$ iff $\pi \models \phi$ for all $\pi \in \text{Paths}(s)$
        \item $s \models E \phi$ iff $\pi \models \phi$ for some $\pi \in \text{Paths}(s)$
    \end{itemize}
\end{center}

for a state $s \in S$ by:

\begin{center}
    \begin{itemize}
        \item $\pi \models X \Phi$ iff $\pi_1 \models \Phi$
        \item $\pi \models \Phi_1 U \Phi_2$ iff there is $i \geq 0$ s.t. $\pi_1 \models \Phi_2$ and $\pi_j \models \Phi_1$ for all $0 \leq j < i$
    \end{itemize}

\end{center}

where the path $\pi$ is viewed as sequence of states $\pi_0, \pi_1, ...$

\pagebreak

Some examples:

\begin{figure}[ht]
    \centering
    \includegraphics[width=4in]{models/images/ctl.png}
\end{figure}

We can transform a state CTL formula into an LTL one by simply omitting the quantifiers over paths. The resulting formula is equivalent to the original one if and only if the property defined by the original CTL formula is expressible in LTL.

For example, $AXa \rightarrow \bigcirc A$, $A(aUb) \rightarrow aUb$.

However, $AFAGa \rightarrow \diamond \square a$ which is not equivalent. Therefore, $AFAGa$ has no equivalent LTL formula and $\diamond \square a$ has no equivalent CTL formula. Thus, CTL and LTL are incomparable.
\\

\subsection{CTL*}

A state formula in CTL* is defined by the following grammar:

\begin{center}
    $\Phi = \text{true} | a | \Phi_1 \wedge \Phi_2 | \neg \Phi | A \phi | E \phi$
\end{center}

where $a$ is an atomic proposition, $\Phi_1, \Phi_2$ are state-formulae and $\phi$ is a path formula defined by:

\begin{center}
    $\phi = \Phi | \phi_1 \wedge \phi_2 | \neg \phi | X \Phi | G \Phi | F \Phi | \Phi_1 U \Phi_2 | \Phi_1 W \Phi_2$
\end{center}

where a path satisfies the state formula if and only if the start state of the path satisfies it:

\begin{center}
    $\pi \models \Phi$ iff $\pi_0 \models \Phi$
\end{center}

\subsection{Model Checking CTL}

Existential Normal Form for CTL is a formula in CTL that may be generated by the following grammar:

\begin{center}
    $\Phi = \text{true} | a | \Phi_1 \wedge \Phi_2 | \neg \Phi | EX\Phi | E(\Phi_1 U \Phi_2) | EG \Phi$ 
\end{center}

Given a TS $(S, \rightarrow, I, AP, L)$ for a CTL formula $\Phi$, denote $\text{Sat}(\Phi)$ by the subset of states that satisfy $\Phi$:

\begin{center}
    $\text{Sat}(\Phi) = \{s \in S | s \models \Phi \}$
\end{center}
\\

Computing $\text{Sat}(\Phi)$ recursively can be done as follows:

\begin{itemize}
    \item $\text{Sat}(\text{true}) = S$ (anything satisfies a formula consisting only of true)
    \item $\text{Sat}(a) = \{s \in S | a \in L(s)\}$ for every $a \in AP$ (the set of all worlds that the AP $a$ is in)
    \item $\text{Sat}(\Phi_1 \wedge \Phi_2) = \text{Sat}(\Phi_1) \bigcap \text{Sat}(\Phi_2)$
    \item $\text{Sat}(\neg \Phi) = S \backslash \text{Sat}(\Phi)$ 
    \item $\text{Sat}(EX \Phi) = \{s \in S | \text{succ}(s) \bigcap \text{Sat}(\Phi) \neq \emptyset\}$ (The set of successor states taken with the difference of $\Phi$ is non empty)
    \item $\text{Sat}(E(\Phi_1 U \Phi_2))$ is the smallest $T \subseteq S$ such that:
        \begin{itemize}
            \item $\text{Sat}(\Phi_2) \subseteq T$ and
            \item $s \in \text{Sat}(\Phi_1)$ and $\text{succ}(s) \bigcap T \neq \emptyset$ implies $s \in T$.
        \end{itemize}
    \item $\text{Sat}(EG \Phi)$ is the biggest $T \subseteq S$ such that:
        \begin{itemize}
            \item $T \subseteq \text{Sat}(\Phi)$and
            \item $s \in T$ implies $\text{succ}(s) \bigcap T \neq \emptyset$
        \end{itemize}
\end{itemize}

where $\text{succ}(s)$ is the set of the direct successors of $s$
\\

To calculate the last two clauses:

\begin{itemize}
    \item $\text{Sat}(E(\Phi_1 U \Phi_2))$ is the smallest $T \subseteq S$ such that:
        \begin{itemize}
            \item Start with $T = \text{Sat}(\Phi_2)$ and
            \item If there is $s \notin T$ with $s \in \text{Sat}(\Phi_1)$ and $\text{succ}(s) \bigcap T \neq \emptyset$ then add $s$ into $T$.
        \end{itemize}
    \item $\text{Sat}(EG \Phi)$ is the biggest $T \subseteq S$ such that:
        \begin{itemize}
            \item Start with $T = \text{Sat}(\Phi)$ and
            \item If there is $s \in T$ with $\text{succ}(s) \bigcap T = \emptyset$ then remove $s$ from $T$.
        \end{itemize}
\end{itemize}

Stop when no such $s$ is found.

\end{document}
