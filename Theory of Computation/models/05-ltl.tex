\documentclass[../models.tex]{subfiles}

\begin{document}

\subsection{LTL Formulae}

We have a Boolean State in which a number of atomic propositions (AP) are true or false. We'd like to reason about discrete linear time, a sequence of states $A_0,A_1,...$ with state $A_0$ at time 0 being the current state (so any propositional formula over the AP talks about $A_0$)

We'd like to add temporal modalities, such as "always $a$" ( $\square a$ ), "eventually $a$" ( $\diamond a$ ), "next $a$" ( $\bigcirc a$ ), etc. These talk about entire sequences. These let us express other temporal properties like "infinitely often" ( $\square \diamond a$ )
\\

We are given a finite set of $AP$s (boolean variables), boolean connectives and two temporal modalities $\bigcirc$ (next) and $\bigcup$ (until)

A formula in LTL is defined by the following grammar:

\begin{center}
    $\phi := \text{true} | a | \phi_1 \wedge \phi_2 | \neg \phi | \bigcirc \phi | \phi_1 \bigcup \phi_2$
\end{center}

where $a \in AP$ and $\phi_1, \phi_2$ are LTL formulae.

Other modalities can be expressed in terms of these basic components:

\begin{center}
    $\diamond a = \text{true} \bigcup a$

    $\square a = \neg \diamond \neg a$
\end{center}

\begin{figure}[ht]
    \centering
    \includegraphics[width=4in]{models/images/ltl.png}
\end{figure}
\vspace{0.5cm}

A world is labelled by the $AP$s that are true in it, so it is a letter from the alphabet $2^{AP}$. 

\textit{The set of all subsets of $AP$. It is a binary alphabet as the $AP$s can only be true or false.}

A word $\sigma$ is an infinite sequence of worlds, describing the world throughout discrete linear time infinitely. ( $\sigma \in (2^{AP})^\omega$ )
\\

\subsection{Satisfaction}

The satisfaction relation $\sigma \models \phi$, where $\sigma = A_0, A_1, ...$ is a word and $\phi$ is a formula, is defined recursively by:

\begin{itemize}
    \item $\sigma \models \text{true}$
    \item $\sigma \models a$ iff $a \in A_0$ \textit{(if the $AP a$ is in the present world)}
    \item $\sigma \models \phi_1 \wedge \phi_2$ iff $\sigma \models \phi_1$ and $\sigma \models \phi_2$
    \item $\sigma \models \neg \phi$ iff $\sigma \nvDash \phi$
    \item $\sigma \models \bigcirc \phi$ iff $A_1 ... \models \phi$ \textit{(if the formula is entailed in all worlds after the present time)}
    \item $\sigma \models \phi_1 \bigcup \phi_2$ iff there is $i \geq 0$ s.t. $A_i ... \models \phi_2$ and $A_j ... \models \phi_1$ for all $0 \leq j \leq i$. \textit{( $\phi_1$ remains true until $\phi_2$ becomes true along the sequence of worlds $\sigma$. Then arbitrary worlds can happen. )}
\end{itemize}

The set of all words that satisfy a formula $\phi$ is called $\text{Words}(\phi)$
\\
\subsection{Transition Systems}

A transition system $TS$ has:

\begin{itemize}
    \item A finite set of states $S$
    \item A transition relation $\rightarrow \subseteq S \times S$ which is left-total (for every $s_1 \in S$ there is a $s_2 \in S$ such that $s_1 \rightarrow s_2$)
    \item A set of initial states $I \subseteq S$
    \item A finite set of atomic propositions $AP$ \textit{(set of boolean variables)}
    \item A labelling function $L:S \rightarrow 2^{AP}$ \textit{(Function of states to worlds)}
\end{itemize}

The transitions may be labelled by a finite set of actions $\text{Act}$. In which case, the transition relation becomes $\rightarrow \subseteq S \times \text{Act} \times S$. 
\\

A run of a $TS$ is an infinite sequence of states $s_0 \rightarrow s_1 \rightarrow ... $where $s_0 \in I$, which produces an infinite trace $\sigma \in (2^{AP})^\omega, \sigma = L(s_0)L(s_1)...$

\textit{Essentially, the $TS$ prints the current state of the world each transition by some labelling function converting states into labels.}
\\

The set of all possibles traces of the $TS$ is called $\text{Traces}(TS)$

So, $TS$ satisfies $\phi$ (written $TS \models \phi$) if $\text{Traces}(TS) \subseteq \text{Words}(\phi)$. In English, all traces in the $TS$ must satisfy the formula $\phi$.

\textit{All sequences of worlds generated by $TS$ must satisfy the formula.}

Interestingly, this means that both $TS \nvDash \phi$ and $TS \nvDash \neg \phi$ can be true.
\\

\subsection{Model Checking}

If we are given a TS $\tau$ and an LTL formula $\phi$, both over the same set of atomic propositions AP, the task is to decide if $\tau \models \phi$.

That is, if all runs of $\tau$ satisfy $\phi$ ( $\text{Traces}(\tau) \subseteq \text{Words}(\phi)$ )

\textit{Equivalently, $\text{Traces}(\tau) \bigcap ((2^{AP})^\omega \setminus \text{Words}(\phi)) = \emptyset$} which is also equivalent to $\text{Traces}(\tau) \bigcap \text{Words}(\neg \phi) = \emptyset$
\\

So if both the runs of $\tau$ and the models of $\phi$ are represented as Buchi Automaton, we can construct the intersection and check for emptiness. If it is empty, $\tau \models \phi$ otherwise return the run of $\tau$ that falsifies $\phi$.
\\

Transforming a TS into a Buchi Automaton is trivial. Simply move each label from the state onto all outgoing transitions and introduce a new start state (of the automaton) instead of multiple ones (of the TS)

Constructing the intersection of two BA is easy (making sure that we alternate infinitely often in the accepting states of the two) and so is checking a BA for emptiness (the language recognised by the Buchi Automaton is non-empty if and only if there is a final state reachable from the start state that lies on a cycle)

Transforming an LTL formulae into an equivalent BA is not so easy. We first translate into a Generalised BA that has multiple accepting states with an acceptance condition is that a state from each set is visited infinitely often. A GBA can then be transformed into an equivalent BA.
\\

\subsection{LTL into Buchi}

A state has two components:

\begin{itemize}
    \item A subset of the AP consisting of all the variables that are true that records the current state of the world, which is the last input symbol seen.
    \item A subset of all sub-formulae of the $\phi$ that should be true in the future from this state onward.
    \item \textit{For example, if $\phi = \bigcirc(\neg b \vee ((a \wedge b) \bigcup \neg b))$ then all sub-formulae are:}
        \begin{itemize}
            \item $\neg b$
            \item $a \wedge b$
            \item $(a \wedge b) \bigcup \neg b$
            \item $\neg b \vee ((a \wedge b) \bigcup \neg b)$
            \item $\bigcirc (\neg b \vee ((a \wedge b) \bigcup \neg b))$
        \end{itemize}
    \item A state must be propositionally consistent
\end{itemize}
\\

A transition from $s_1$ into $s_2$ labelled by $a \in 2^{AP}$ is added if:

\begin{itemize}
    \item The label $a$ matches the first component of the state $s_2$ and-
    \item The state $s_1$ has the sum formula $\bigcirc \psi$ if and only if the state $s_2$ has the sub-formula (or AP) $\psi$. (This handles the Next operator). and -
    \item Whenever the state $s_1$ has the sub-formula $\phi_1 \bigcup \phi_2$:
        \begin{itemize}
            \item The state $s_1$ has $\phi_2$ or
            \item The state $s_1$ has $\phi_1$ and the state $s_2$ has $\phi_1 \bigcup \phi_2$
            \item \textit{This partly handles the Until operator}
        \end{itemize}
\end{itemize}

The expansion of the until operator doesn't guarantee that $\phi_2$ eventually happens. Thus, any infinite run that always has $\phi_1 \bigcup \phi_2$ but never $\phi_2$ is inconsistent. We can prevent this inconsistency though by insisting every run has states that have $\phi_2$ or haven't $\phi_1 \bigcup \phi_2$ infinitely often.

Thus, for every sub-formula of the form $\phi_1 \bigcup \phi_2$ we introduce an accepting set of states that contains every state that has $\phi_2$ or hasn't $\phi_1 \bigcup \phi_2$.
\\

Finally, we introduce a start state $s_0$ that has a transition to a state $s$ which is labelled with the first component of $s$ only if the formula $\phi$ is in the second component of $s$.

\end{document}
